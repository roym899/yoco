{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>YOCO is a minimalistic YAML-based configuration system for Python.</p>"},{"location":"#installation","title":"Installation","text":"<p>Run</p> <pre><code>pip install yoco\n</code></pre> <p>to install the latest release of YOCO.</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>This module contains all YOCO functions to load and save configurations.</p> <p>YOCO is based on Python dictionaries and YAML files to provide a simple, yet powerful way of configuring Python projects. YOCO supports specifying parameters through the command line, YAML-files or directly from a Python dictionary.</p>"},{"location":"api_reference/#yoco.load_config","title":"<code>load_config(config_dict, current_dict=None, parent=None, search_paths=None)</code>","text":"<p>Load a config dictionary.</p> <p>If a key is already in current_dict, config_dict will overwrite it.</p> <p>Parameters:</p> Name Type Description Default <code>config_dict</code> <code>dict</code> <p>Configuration dictionary to be parsed.</p> required <code>current_dict</code> <code>Optional[dict]</code> <p>Current configuration dictionary to be updated, will not be changed.</p> <code>None</code> <code>parent</code> <code>Optional[str]</code> <p>Path of parent config. Used to resolve relative paths.</p> <code>None</code> <code>search_paths</code> <code>Optional[List[str]]</code> <p>Search paths used to resolve config files. See resolve_path for more information.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Loaded / updated configuration dictionary.</p> Source code in <code>yoco.py</code> <pre><code>def load_config(\n    config_dict: dict,\n    current_dict: Optional[dict] = None,\n    parent: Optional[str] = None,\n    search_paths: Optional[List[str]] = None,\n) -&gt; dict:\n    \"\"\"Load a config dictionary.\n\n    If a key is already in current_dict, config_dict will overwrite it.\n\n    Args:\n        config_dict: Configuration dictionary to be parsed.\n        current_dict:\n            Current configuration dictionary to be updated, will not be changed.\n        parent: Path of parent config. Used to resolve relative paths.\n        search_paths:\n            Search paths used to resolve config files.\n            See resolve_path for more information.\n\n    Returns:\n        Loaded / updated configuration dictionary.\n    \"\"\"\n    config_dict = copy.deepcopy(config_dict)\n    if current_dict is None:\n        current_dict = {}\n    else:\n        current_dict = copy.deepcopy(current_dict)\n\n    # 1. handle config key if present\n    if \"config\" in config_dict:\n        current_dict = _resolve_config_key(\n            config_dict, current_dict, parent, search_paths\n        )\n\n    config_dict.pop(\"config\", None)\n\n    # 2. handle !include tag\n    config_dict = _resolve_include_tags_recursively(config_dict, parent, search_paths)\n\n    # 3. resolve automatically recognized paths (./, ../, ~)\n    if parent is not None:\n        _resolve_paths_recursively(config_dict, parent)\n\n    # 4. merge config_dict into current_dict\n    current_dict = _merge_dictionaries(current_dict, config_dict)\n\n    return current_dict\n</code></pre>"},{"location":"api_reference/#yoco.load_config_from_args","title":"<code>load_config_from_args(parser, args=None, search_paths=None)</code>","text":"<p>Parse arguments and load configs into a config dictionary.</p> <p>Strings following -- will be used as key. Dots in that string are used to access nested dictionaries. YAML will be used for type conversion of the value.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>Parser used to parse known and unknown arguments. This function will handle both the known args that have been added before and it tries to parse all other args and integrate them into the config.</p> required <code>args</code> <code>Optional[list]</code> <p>List of arguments to parse. If None, sys.argv[1:] is used.</p> <code>None</code> <code>search_paths</code> <code>Optional[List[str]]</code> <p>Search paths used to resolve config files. See resolve_path for more information.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Loaded configuration dictionary.</p> Source code in <code>yoco.py</code> <pre><code>def load_config_from_args(\n    parser: _argparse.ArgumentParser,\n    args: Optional[list] = None,\n    search_paths: Optional[List[str]] = None,\n) -&gt; dict:\n    \"\"\"Parse arguments and load configs into a config dictionary.\n\n    Strings following -- will be used as key. Dots in that string are used to access\n    nested dictionaries. YAML will be used for type conversion of the value.\n\n    Args:\n        parser:\n            Parser used to parse known and unknown arguments.\n            This function will handle both the known args that have been added before\n            and it tries to parse all other args and integrate them into the config.\n        args:\n            List of arguments to parse. If None, sys.argv[1:] is used.\n        search_paths:\n            Search paths used to resolve config files.\n            See resolve_path for more information.\n\n    Returns:\n        Loaded configuration dictionary.\n    \"\"\"\n    # parse arguments\n    no_default_parser = copy.deepcopy(parser)\n    for a in no_default_parser._actions:\n        if a.dest != \"config\":\n            a.default = None\n    known, other_args = no_default_parser.parse_known_args(args)\n\n    known_with_default, _ = parser.parse_known_args(args)\n\n    config_dict = {k: v for k, v in vars(known).items() if v is not None}\n    with_default_config_dict = {\n        k: v for k, v in vars(known_with_default).items() if v is not None\n    }\n    with_default_config_dict.pop(\"config\", None)\n\n    config_dict = load_config(config_dict, search_paths=search_paths)\n    current_key = None\n\n    # list of unknown args (all strings) to dictionary\n    # [--arg_1, val_1, --arg_2, val_2_a, val_2_b, ...]\n    # -&gt; {arg_1: val_1, arg_2: \"{val_2_a} {val_2_b}, ...}\n    arg_dict = {}\n    for arg in other_args:\n        if arg.startswith(\"--\"):\n            current_key = arg.replace(\"--\", \"\")\n            arg_dict[current_key] = []\n        else:\n            if current_key is None:\n                parser.error(\n                    message=\"General args need to start with --name {values}\\n\"\n                )\n            arg_dict[current_key].append(arg)\n    arg_dict = {key: \" \".join(values) for key, values in arg_dict.items()}\n    # done parsing args, stored in arg_dict\n\n    # integrate arg, value pairs into config_dict loaded before, one by one\n    # args can set nested values by using dots\n    # i.e., a.b.c will result in the following add_dict: {\"a\": {\"b\": {\"c\": value}}}\n    # \"config\" can still be used to load files\n    for arg, value in arg_dict.items():\n        add_dict = {}\n        current_dict = add_dict\n        hierarchy = arg.split(\".\")\n        for a in hierarchy[:-1]:\n            current_dict[a] = {}\n            current_dict = current_dict[a]\n        # parse value using yaml (this allows setting lists, dictionaries, etc.)\n        current_dict[hierarchy[-1]] = _yaml.load(value)\n\n        if hierarchy[0] == \"config\":\n            # handle special \"config\" key by loading the nested dict as root dict\n            # this will practically replace \"config\" key with the dict from\n            # the specified file\n            add_dict = load_config(add_dict, search_paths=search_paths)\n            # config file -&gt; lower priority than what is already there\n            config_dict = load_config(config_dict, add_dict, search_paths=search_paths)\n        else:\n            # integrate nested dictionary into config_dict loaded before\n            # normal argument -&gt; higher priority than what is arleady there\n            config_dict = load_config(add_dict, config_dict)\n\n    # add default values last (lowest priority) if they weren't specified so far\n    config_dict = _merge_dictionaries(with_default_config_dict, config_dict)\n\n    return config_dict\n</code></pre>"},{"location":"api_reference/#yoco.load_config_from_file","title":"<code>load_config_from_file(path, current_dict=None, parent=None, search_paths=None)</code>","text":"<p>Load configuration from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path of YAML file to load.</p> required <code>current_dict</code> <code>Optional[dict]</code> <p>Current configuration dictionary. Will not be modified. If None, an empty dictionary will be created.</p> <code>None</code> <code>parent</code> <code>Optional[str]</code> <p>Parent directory. If not None, path will be assumed to be relative to parent.</p> <code>None</code> <code>search_paths</code> <code>Optional[List[str]]</code> <p>Search paths used to resolve config files. See resolve_path for more information.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Updated configuration dictionary.</p> Source code in <code>yoco.py</code> <pre><code>def load_config_from_file(\n    path: str,\n    current_dict: Optional[dict] = None,\n    parent: Optional[str] = None,\n    search_paths: Optional[List[str]] = None,\n) -&gt; dict:\n    \"\"\"Load configuration from a file.\n\n    Args:\n        path: Path of YAML file to load.\n        current_dict:\n            Current configuration dictionary. Will not be modified.\n            If None, an empty dictionary will be created.\n        parent:\n            Parent directory.\n            If not None, path will be assumed to be relative to parent.\n        search_paths:\n            Search paths used to resolve config files.\n            See resolve_path for more information.\n\n    Returns:\n        Updated configuration dictionary.\n    \"\"\"\n    if current_dict is None:\n        current_dict = {}\n\n    full_path = resolve_path(path, parent, search_paths)\n\n    parent = _os.path.dirname(full_path)\n\n    with open(full_path) as f:\n        config_dict = _yaml.load(f)\n        current_dict = load_config(config_dict, current_dict, parent, search_paths)\n\n    return current_dict\n</code></pre>"},{"location":"api_reference/#yoco.resolve_path","title":"<code>resolve_path(path, parent=None, search_paths=None)</code>","text":"<p>Resolves a path to a full absolute path based on parent and search_paths.</p> <p>This function considers paths of 5 different cases:</p> <ul> <li><code>/...</code> Absolute path, nothing todo.</li> <li><code>~/...</code> Home dir, expand user.</li> <li><code>./...</code> Relative to parent (current directory if parent is None).</li> <li><code>../...</code> Relative to parent (current directory if parent is None).</li> <li><code>...</code>     Relative to search paths.     If search_paths is None: relative to parent and current working directory     is assumed, in that order (i.e., <code>search_paths=[\".\", \"\"]</code>).</li> </ul> <p>Relative search paths such as <code>\".\"</code> or <code>\"./\"</code> will be relative to parent (or current directory if parent is None). The empty search path <code>\"\"</code> refers to the current directory and is not automatically included.</p> <p>I.e., if parent is None <code>\".\"</code> and <code>\"\"</code> refer to the same path. While if parent is not None, <code>\".\"</code> means relative to the parent and <code>\"\"</code> means relative to current directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to resolve.</p> required <code>parent</code> <code>Optional[str]</code> <p>Parent folder. Will be used for explicit relative paths (./ or ../).</p> <code>None</code> <code>search_paths</code> <code>Optional[List[str]]</code> <p>List of search paths to prepend relative paths which are not explicitly relative to current directory. If None, no search paths are assumed.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The normalized resolved path. Original path, if path could not be resolved.</p> Source code in <code>yoco.py</code> <pre><code>def resolve_path(\n    path: str, parent: Optional[str] = None, search_paths: Optional[List[str]] = None\n) -&gt; str:\n    \"\"\"Resolves a path to a full absolute path based on parent and search_paths.\n\n    This function considers paths of 5 different cases:\n\n    - `/...` Absolute path, nothing todo.\n    - `~/...` Home dir, expand user.\n    - `./...` Relative to parent (current directory if parent is None).\n    - `../...` Relative to parent (current directory if parent is None).\n    - `...`\n        Relative to search paths.\n        If search_paths is None: relative to parent and current working directory\n        is assumed, in that order (i.e., `search_paths=[\".\", \"\"]`).\n\n    Relative search paths such as `\".\"` or `\"./\"` will be relative to parent (or current\n    directory if parent is None). The empty search path `\"\"` refers to the current\n    directory and is not automatically included.\n\n    I.e., if parent is None `\".\"` and `\"\"` refer to the same path. While if parent is\n    not None, `\".\"` means relative to the parent and `\"\"` means relative to current\n    directory.\n\n    Args:\n        path: The path to resolve.\n        parent: Parent folder. Will be used for explicit relative paths (./ or ../).\n        search_paths:\n            List of search paths to prepend relative paths which are not explicitly\n            relative to current directory.\n            If None, no search paths are assumed.\n\n    Returns:\n        The normalized resolved path. Original path, if path could not be resolved.\n    \"\"\"\n    if search_paths is None:\n        search_paths = [\".\", \"\"]\n    if parent is None:\n        parent = \".\"\n\n    # handle paths starting with / or ~\n    if _os.path.isabs(path):\n        return _os.path.normpath(path)\n    elif path.startswith(\"~/\"):\n        return _os.path.normpath(_os.path.expanduser(path))\n\n    # handle paths starting with . or ..\n    parts = path.split(_os.sep)\n    if parts[0] in [\".\", \"..\"]:\n        return _os.path.normpath(_os.path.join(parent, path))\n\n    # handle paths without prefix\n    for search_path in search_paths:\n        resolved_path = resolve_path(_os.path.join(search_path, path), parent, [])\n        if _os.path.exists(resolved_path):\n            return _os.path.normpath(resolved_path)\n\n    return path\n</code></pre>"},{"location":"api_reference/#yoco.save_config_to_file","title":"<code>save_config_to_file(path, config_dict)</code>","text":"<p>Save config dictionary as a yaml file.</p> Source code in <code>yoco.py</code> <pre><code>def save_config_to_file(path: str, config_dict: dict) -&gt; None:\n    \"\"\"Save config dictionary as a yaml file.\"\"\"\n    with open(path, \"w\") as f:\n        _yaml.dump(config_dict, f)\n</code></pre>"}]}